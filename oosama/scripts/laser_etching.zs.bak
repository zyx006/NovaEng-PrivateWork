#priority 50
#loader crafttweaker reloadable

import crafttweaker.item.IItemStack;
import crafttweaker.item.IIngredient;
import crafttweaker.data.IData;
import crafttweaker.world.IWorld;
import crafttweaker.item.IWeightedIngredient;

import mods.modularmachinery.RecipeBuilder;
import mods.modularmachinery.RecipeCheckEvent;
import mods.modularmachinery.RecipeStartEvent;
import mods.modularmachinery.RecipeFinishEvent;
import mods.modularmachinery.RecipeModifierBuilder;
import mods.modularmachinery.IngredientArrayBuilder;

import mods.modularmachinery.MMEvents;
import mods.modularmachinery.ControllerGUIRenderEvent;
import mods.modularmachinery.FactoryRecipeThread;
import mods.modularmachinery.FactoryRecipeTickEvent;
import mods.modularmachinery.FactoryRecipeStartEvent;
import mods.modularmachinery.FactoryRecipeFinishEvent;

import mods.modularmachinery.IMachineController;
import mods.modularmachinery.MachineModifier;

// 全局常量
static maxet_lq as int = 10000000; // 最大冷却储备
static COOLANT_PER_TICK as int = 100000; // 每次注入冷却液量

MachineModifier.setMaxThreads("laser_etching", 8);
MachineModifier.addCoreThread("laser_etching", FactoryRecipeThread.createCoreThread("液态冷却注入").addRecipe("et_lq_etching"));
MachineModifier.addCoreThread("laser_etching", FactoryRecipeThread.createCoreThread("维护冷却核心").addRecipe("link_etching"));

//超维度激光雕刻控制器
RecipeBuilder.newBuilder("laser_etching", "workshop", 300)
    .addEnergyPerTickInput(100000)
    .addInputs([
        <contenttweaker:industrial_circuit_v3> * 8,
        <contenttweaker:electric_motor_v3> * 8,
        <contenttweaker:sensor_v3> * 16,
        //<mekanismgenerators:generator:6> * 16,
        //<modularmachinery:blockcasing:4>,
        //<mets:te:4>*8,
    ])
    .addOutput(<modularmachinery:laser_etching_factory_controller>)
    .build();


//GUI
MMEvents.onControllerGUIRender("laser_etching", function(event as ControllerGUIRenderEvent) {
    val ctrl = event.controller;
    val data = ctrl.customData;
    val dData = D(data);
        val et_lq = dData.getInt("et_lq",0);
    var info as string[] = [
            "§9当前缓存魔力:§a" + et_lq + "§9/§a" + maxet_lq,
    ];
    event.extraInfo = info;
});
//输入魔力
    RecipeBuilder.newBuilder("et_lq_etching","laser_etching", 20, 0)
    .addInput(<liquid:cryotheum> * 100)
        .addPreCheckHandler(function(event as RecipeCheckEvent){
        val ctrl = event.controller;
        val data = ctrl.customData;
        val dData = D(data);
            val et_lq = dData.getInt("et_lq",0);
            if (et_lq >= maxet_lq){
                event.setFailed("冷却核心已就绪！");
            return;
        }
            event.activeRecipe.maxParallelism = 10;
    })
        .addFactoryStartHandler(function(event as FactoryRecipeStartEvent){
        val ctrl = event.controller;
        val data = ctrl.customData;
        val dData = D(data);
            val et_lq = dData.getInt("et_lq",0);
            data.asMap()["et_lq"] = et_lq + 100000 * event.activeRecipe.parallelism;
        ctrl.customData = data;
    })
    .setMaxThreads(1)
    .addRecipeTooltip("向其中注入冷却液,每并行 §e100000§f 点。")
    .setThreadName("液态冷却注入")
    .setParallelized(true)
    .build();

//链接维护
    RecipeBuilder.newBuilder("link_etching","laser_etching",1000000000, 0)
        .addPreCheckHandler(function(event as RecipeCheckEvent){
        val ctrl = event.controller;
        val data = ctrl.customData;
        val dData = D(data);
            val et_lq = dData.getInt("et_lq",0);
            if (et_lq < 2000000){
            event.setFailed("冷却核心储备不足！");
            return;
        }
    })
       .addFactoryPreTickHandler(function(event as FactoryRecipeTickEvent) {
    val ctrl = event.controller;
    val data = ctrl.customData;
    val dData = D(data);
    val et_lq = dData.getInt("et_lq", 0);

    // 如果时间未到，阻止进度
    if (ctrl.world.time % 200 != 0) {
        event.preventProgressing("正在保持链接");
        return; // 提前退出，避免后续逻辑执行
    }

    // 如果冷却储备不足，设置失败并退出
    if (et_lq <= 0) {
        event.setFailed(true, "魔力不足以保持运行");
        return;
    }

    // 扣除冷却液并允许进度
    data.asMap()["et_lq"] = et_lq - COOLANT_PER_TICK; // 扣除冷却液
    ctrl.customData = data;
})
.setMaxThreads(1)
.addRecipeTooltip("开始运行需要注入冷却！")
.setThreadName("冷却核心监控")
.setParallelized(false)
.build();